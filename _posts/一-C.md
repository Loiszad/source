---
title: (一)C
date: 2014-2-25 16:08:27
tags:
categories: C
---

### 1.Hello World
1. mac命令行自动补全 Tab
1. mac显示隐藏文件 cmd+shift+.

```
① vi hello.c
② gcc -o hello hello.c
③ ./hello
```

### 2.原码、反码、补码
1. 八位一字节，计算机最少分配一字节
1. 无论正数负数，计算机都是以二进制补码形式存储

```
正数的 原码、反码、补码三位一体
负数的 原码在正数原码基础上只改变符号位， 反码在原码基础上符号位不变其他位按位取反， 补码在反码基础上+1
```

### 3.数组、指针
1. 打印指针 %p
1. 指针变量加1，即向后移动1 个位置表示指针变量指向下一个数据元素的首地址。
1. 数组名是一个地址常量

```
int arr[5] = {1,2,3,4,5};//完全初始化
arr[0] = 1;
arr[0+1] = 2;
arr[3>2] = 1; //下标不必须是一个数字，可以是一个表达式

int arr[5] = {1,2,3}//部分初始化，没有初始化的元素被置为0


//数组不能整体赋值
int a[5];
a = {1,2,3,4,5} // 编译不通过
printf("%d",a[6])//是可以打印的

//星前const: p可变，*p不能改变，也可以说不能通过*p修改a的值
char a = 'A';
const char *p = &a;
char const *p = &a;

//星后const: p不可改变，*p可改
char * const p = &a;

//都不可改变
const char * const p = &a;

```


### 4.指针数组和数组指针

```
//指针数组 元素是指针
int *p[5];  //[]比*的优先级高，所以首先它是一个数组

//数组指针 指向数组的指针
int (*p)[5]; //可以把它看成 int a[5]
int a[5] = {1,2,3,4,5};
p = &a;

```


### 5.函数指针
1. 函数名是函数的入口地址

```
#include <stdio.h>

int func(void){

	printf("%s\n", "11111");
	return 0;

}

int main(int argc, char const *argv[])
{

	int (*p) (void) = func; //把*p看成一个整体 int a(void)

	printf("%p\n", func);
	//两者都是正确的,函数指针和函数名在调用的时候是一样的效果。从纯语法来说。（*p）（）比较标准。但是p()也是可以的。关键是这样写编译器也可以识别.
	printf("%d\n", p());
	printf("%d\n", (*p)());

	return 0;
}
```